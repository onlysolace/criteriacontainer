#summary Release Notes

== Release 0.4.6 == 
  * CriteriaContainer now supports nested retrieval
        container.addContainerProperty("assignee.class",...);
        table.setVisibleColumn("assignee.class");
    The items of the container will then retrieve the value of assignee.getClass() when
    accessing the "assignee.class" property.
    Any string that can be understood by Jakarta PropertyUtils.getProperty can be
    used (e.g. person.address.zipcode or even person.children[0])
    However, there must be an accessor (getX() or isX()) for this to work.

== Release 0.4.5 ==
  * setKeyPropertyId() can be used to state that the container should return a key
    from the underlying data source instead of the index in the container. For example
    taskContainer.setKeyPropertyId("taskId") would return the taskId column.  This is 
    normally used when using the container with a Select, where it is useful to store
    a foreign key.  NOTE: the Vaadin 6.5 implementation of Select performs a getItemIds()
    call, and is NOT lazy.  This means that Select cannot be used for large data sets.
    If selecting from a large dataset, you probably need to use a Table, which does NOT
    attempt to get all the itemIds at once.
  * Fixed a bug regarding the computation of the "startingAt" index for retrieval; under
    certain circumstances that index was not being reset to 0 as it should be (e.g. after
    scrolling to the very end of the container and then sorting).
  
== Release 0.4.4 ==
  * If a BeanTupleContainer returned a single column with distinct values
    the size() returned was incorrect. 

== Release 0.4.3 ==
  * properties inferred from query were not always automatically added to container
  * a call to container.refresh() was sometimes needed to trigger display in a table. 

== Release 0.4.2 ==
  * addEntity() for a CriteriaContainer no longer throws an exception when casting a BeanItem.
    
== Release 0.4.1 ==
  * Improvement in the API for FilterRestriction to make it possible to filter on any selection in the returned
    tuple.
  * Updated Javadoc

== Release 0.4.0 ==
  * The main container is now BeanTupleContainer.  An arbitrary criteria query can be used to retrieve
    a JPA Tuple; for normal usage, the JPA Tuple will contain one or more entities, and computed
    values.  The entities retrieved in the tuple can be edited.
  * For retrieving a single kind of entity, use CriteriaContainer
    * CriteriaContainer has been rebuilt on top of BeanTupleContainer
    * CriteriaContainer infers automatically the properties of the container
    * CriteriaContainer supports adding items.
  * Demos have been fixed.
  * TupleContainer has been subsumed by BeanTupleContainer and removed.
    
== Release 0.3.0 ==
  * Added BeanTupleContainer which allows retrieval of a tuple made up of editable Beans.  All
    the container configuration is done by examining the JPA2.0 query.

== Release 0.2.0 ==
  * Moved the entityManager back to the CritQueryDefinition constructor, as in the original API.

== Release 0.1.1 ==
  * Enabled sorting.
  
== Release 0.1.0 ==
  * Initial Release
  
  * Added ability to define JPA 2.0 type-safe Criteria query
    Programming a query is done essentially by defining predicates
    
		// WHERE t.name LIKE ...
		Predicate condition = cb.like(
				t.get(Task_.name), // t.name
				nameFilterValue);  // "like" pattern to be matched
		filterExpressions.add(condition);
	
	The SQL is entirely generated by the Criteria API.  There is no text string manipulation
	to build a query.  The use of Java variables such as Task_.name will give a compile-time
	error where the	@Entity classes have changed, but the queries have not been updated.
	The variables are generated automatically by Maven or the IDE (see next item)
    
  * Tested with Hibernate; used Eclipse annotation processing to generate the JPA Metamodel
    (see http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/ for use
    with pure Maven)
    
  * For situations that do not warrant full type-safe filtering, a replacement for the filter() method
    from the EntityContainer is provided. A list of restrictions is defined. The objective
    is to avoid any textual manipulation of SQL: the restrictions become JPA Predicate objects.
    
		final LinkedList<CritRestriction> restrictions = new LinkedList<CritRestriction>();
		restrictions.add(new CritRestriction(Task_.beta.getName(), CritRestriction.Operation.GE, 9996));
		criteriaContainer.filter(restrictions);
	
	In such a query, there will be an exception if the name of the field is not part of the returned entity.
	It is therefore recommended to always use the getName() method from the metamodel definition.
	
  * In this release, the Filterable interface is not implemented, but at first analysis it appears
    feasible to add it in a compatible way (allowing additional user-controlled filtering out of the box).